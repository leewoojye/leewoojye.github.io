---
layout: post
title:  "[Java] 상속, 인터페이스, 추상클래스 한번에 알려드림"
date:   2025-07-28 22:31:35 +0900
comments: true
categories: dev
---

## 📌 **상속**

- 상속 관계는 is a 관계 혹은 kind of 관계라고 불리기도 한다.

예제로 확인해보자! )
![](https://velog.velcdn.com/images/leewoojye/post/76a84b47-ce1a-46b9-808c-238f23f0ff3f/image.png)

전자제품은 부모 클래스, 전자레인지는 자식 클래스이다. 전자레인지는 전자제품 클래스로부터 상속을 받았으므로 전원 기능이 함수로 명시 되지 않아도 사용할 수 있다.

여러 종류의 객체를 하나의 이름으로 부를 수 있는 것을 **일반화**하고 한다.

⭐ 즉, 상속 = 일반화(전자제품) + 확장(해동하다)

- 상자 하나하나는 모두 객체이자 클래스이다. 이러한 **계층을** 표현하기 위해 만들어진 개념이 상속이다. 또한 하위 객체는 상위 객체(부모)의 특징을 **물려받는다**.

- 상속은 결합도가 매우 높은 편이기에 반드시 써야 할때만 상속을 사용하는 것이 좋음. 객체는 응집도가 높고 결합도가 낮은 것이 좋기 때문이다.

### **상속 선언 방법**

_[접근 제한자] [abstract | final] class 클래스명 extends 부모 클래스명_

- 아무것도 상속받지 않으면 자동으로 **`java.lang.Object`**를 상속 받는다. 따라서 모든 클래스는 Object의 자손이다.
- 부모 타입으로 자손 타입을 참조할 수 있다.

예)

```java
Car**(참조 타입)** car = new Bus**(인스턴스 타입)**();

Car car = new Bus(); //Car 클래스 속 메소드만 사용할 수 있다.

Bus car = new Bus(); //Bus 클래스에 있는 메소드를 모두 사용할 수 있다.
```

비유로 접근하기!) 버스를 손으로 가리키면서 “자동차다”라고 말할 수 있다. 버스는 자동차의 한 종류이기 때문이다.
<br>

## 📌 **인터페이스**

---

- 어떤 **기능을** 만들어야 할지부터 고민한다. 만들어야 할 기능들을 관련된 것끼리 묶은 후 이름을 지어준다.
- ⭐ 인터페이스는 **기능들의 목록**을 갖고 있다.
- _[public] **interface** 인터페이스이름 {…}_
  - 접근 제한자 생략 가능

### **인터페이스 작성 문법**

- 인터페이스이름은 Upper CamelCase로 작성된다.
- 인터페이스도 확장자가 .java인 파일로 작성한다.
- ⭐⭐ 인터페이스의 모든 **필드는** **`public static final`**이어야 하며, 모든 **메소드는** **`public abstract`**이어야 한다. (java 7까지는) final, abstract를 생략하면 자동으로 붙는다.
- java 8 부터는 **디폴트(default) 메소드와 정적(static) 메소드도** 선언이 가능하다.

- 인터페이스는 추상 클래스처럼 인스턴스로 사용할 수 없다.
- 구현해야 할 메소드를 목록으로 정리하는 느낌으로 인터페이스를 사용한다.
  - 예) 로또 기계는 이러~이러~한 기능들이 필요하다
- ⭐⭐ 인터페이스를 구현하게 되면 반드시 인터페이스가 갖고 있는 메소드를 **오버라이딩할** 필요가 있다.
- 인터페이스는 인스턴스는 될 수 없지만 참조 타입은 될 수 있다.
  - 예) _Car c1 = new Bus();_

<br>

## 📌 **추상 클래스**

---

- ⭐ 추상 클래스는 인스턴스가 될 수 없다.
- 추상 클래스를 상속 받는 자손이 인스턴스가 된다.
- **abstract** 키워드를 사용하여 클래스를 정의한다.
- 추상 클래스는 보통 1개 이상의 추상 메소드를 가진다. (추상 메소드가 없어도 오류 발생 x)
- _public **abstract** class 클래스명 {…}_
- 메소드 일부는 선언만 되어 있고 구현되어 있지 않다.

```java
public abstract class Car2 {
 public abstract void run(); //run()메소드를 자식 클래스마다 다르게 하고 싶을 때
}
```

- ⭐ 추상 클래스를 상속 받은 클래스에선 추상 **메소드를** 직접 구현해 주어야 한다.
<br>

---

## 📌 상속, 인터페이스, 추상클래스 차이점

- **상속 vs. 인터페이스 vs. 추상 클래스 간 차이점?**
  - 추상 클래스 안의 추상 메소드는 하위 클래스에서 반드시 구현해야 하지만, 일반 메소드는 반드시 구현할 필요가 없다. 반면에 인터페이스는 메소드와 상수만 가질 수 있으며, 구현 클래스에서 인터페이스에서 정의한 메소드를 반드시 구현해야 한다.

- ⭐ 메소드 OR 변수를 '구현'하는가 그대로 '사용'하는가에 따라서 상속의 형태가 갈리게 된다.
  - **extends**
    - 부모에서 선언 / 정의를 모두하며, 자식은 메소드 / 변수를 그대로 사용할 수 있음 (오버라이딩도 가능)
  - **implements (interface 구현)**
    - 부모 객체는 **선언만** 하며 정의(내용)은 자식에서 오버라이딩 (재정의) 해서 사용해야함
  - **abstract**
    - extends와 interface 혼합. extends하되 몇 개는 추상 메소드로 구현되어 있음

- 즉, **extends**는 일반 클래스와 abstract 클래스 상속에 사용되고, **implement**는 interface 상속에 사용된다.
- class가 class를 상속받을 땐 extends를 사용하고, interface가 interface를 상속 받을 땐 extends를 사용한다.
- extends는 클래스 한 개만 상속 받을 수 있다. 엄마 아빠가 각각 두 명 될 수 없는 것처럼! 반면 implements는 여러개 사용 가능하다.
- implements한 클래스는 implements의 내용을 다 사용해야 한다.
- extends는 클래스를 확장하는 거고 implements는 인터페이스를 구현하는 것이다.
<br>

**예제) 상속 vs. 인터페이스**

```java
public class Parents {
    protected boolean hairLoss = true;

    public void display(){
        System.out.println("IM PARENT");
    }
}
```

👆 상속 클래스 선언

```java
public interface Programer {
    void programming();
}
public interface Driver {
    void drive();
}
```

👆 인터페이스 선언

```java
public class David extends Parents implements Programer, Driver{
  //Parents는 상속, Programmer/Driver는 인터페이스

     public David(){ //David는 한번에 하나의 상속 클래스를 상속 받을 수 있다. 
        if(this.hairLoss == true){
            System.out.println("I am hairloss..");
        }
    }
    
    @Override
    public void programming() { //David는 한번에 여러 인터페이스를 받을 수 있다.
        System.out.println("I can programming");
    }
    
    @Override
    public void drive() {
        System.out.println("I can drive");
    }
}
```

👆 부모 클래스로부터 상속받고 & 인터페이스도 구현한 클래스

<br>
</br>
